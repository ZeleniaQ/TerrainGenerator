<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8"/>
    <title>Terrain Generator</title>
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <style>
        body { margin: 0; overflow: hidden; background: #fff; font-family: sans-serif; }
        canvas { width: 100vw; height: 100vh; display: block; }
        
        #ui-overlay {
            position: absolute; top: 20px; left: 20px;
            color: #333; pointer-events: none;
            background: rgba(255,255,255,0.7); padding: 15px; border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            z-index: 10; font-size: 13px; line-height: 1.5;
        }
        .key { font-weight: bold; color: #000; background: #eee; padding: 1px 4px; border-radius: 3px; border: 1px solid #ccc; }
        #mode-status { margin-top: 10px; font-weight: bold; color: #d32f2f; }
    </style>
    <script type="importmap">
        {
            "imports": {
                "lil-gui": "https://cdn.jsdelivr.net/npm/lil-gui@0.19/+esm"
            }
        }
    </script>
</head>
<body>
    <div id="ui-overlay">
        <div style="font-weight: bold; margin-bottom: 8px; border-bottom: 1px solid #ccc;">Project Controls</div>
        <div><span class="key">W</span> <span class="key">A</span> <span class="key">S</span> <span class="key">D</span> : Move</div>
        <div><span class="key">↑</span> <span class="key">↓</span> <span class="key">←</span> <span class="key">→</span> : Look Around</div>
        <div><span class="key">F</span> : Fog Toggle | <span class="key">G</span> / <span class="key">H</span> : Fog Density</div>
        <div><span class="key">Enter</span> : Regenerate Terrain</div>
        <div id="mode-status">Current Mode: Flight</div>
    </div>
    <canvas id="glcanvas"></canvas>

    <script type="module">
        import GUI from 'lil-gui';

        const V3 = (x=0,y=0,z=0) => new Float32Array([x,y,z]);
        const add3 = (a,b) => V3(a[0]+b[0], a[1]+b[1], a[2]+b[2]);
        const sub3 = (a,b) => V3(a[0]-b[0], a[1]-b[1], a[2]-b[2]);
        const mul3s = (a,s) => V3(a[0]*s, a[1]*s, a[2]*s);
        const dot3 = (a,b) => a[0]*b[0] + a[1]*b[1] + a[2]*b[2];
        const len3 = a => Math.hypot(a[0], a[1], a[2]);
        const norm3 = a => { const L = len3(a)||1; return V3(a[0]/L, a[1]/L, a[2]/L); };
        const cross3 = (a,b) => V3(a[1]*b[2]-a[2]*b[1], a[2]*b[0]-a[0]*b[2], a[0]*b[1]-a[1]*b[0]);
        
        function rotateVecAroundAxis(v, axis, ang) {
            axis = norm3(axis);
            const c = Math.cos(ang), s = Math.sin(ang);
            const d = (1-c) * dot3(axis, v);
            return V3(
                v[0]*c + (axis[1]*v[2]-axis[2]*v[1])*s + axis[0]*d,
                v[1]*c + (axis[2]*v[0]-axis[0]*v[2])*s + axis[1]*d,
                v[2]*c + (axis[0]*v[1]-axis[1]*v[0])*s + axis[2]*d
            );
        }

        const settings = {
            gridSize: 100,
            faults: 100,
            complexity: 2.2,
            weatheringDegree: 0,
            
            viewMode: 'Flight',
            hoverHeight: 0.15, 
            
            fogOn: false,
            fogDensity: 0.2,
            fogColor: [1.0, 1.0, 1.0],
            
            showCliffs: false,
            materialName: 'rock_surface',
            
            regenerate: () => {
                generateTerrain();
                if(settings.viewMode === 'Drive') resetCamera('Drive');
            }
        };

        const canvas = document.getElementById('glcanvas');
        const gl = canvas.getContext('webgl2', { antialias: true });

        const VS = `#version 300 es
        layout(location=0) in vec3 a_pos;
        layout(location=1) in vec3 a_nrm;
        uniform mat4 u_M, u_V, u_P;
        out vec3 v_wsPos, v_wsNrm;
        void main() {
            vec4 wsPos = u_M * vec4(a_pos, 1.0);
            v_wsPos = wsPos.xyz;
            v_wsNrm = normalize(mat3(u_M) * a_nrm);
            gl_Position = u_P * u_V * wsPos;
        }`;

        const FS = `#version 300 es
        precision highp float;
        in vec3 v_wsPos, v_wsNrm;
        uniform vec3 u_eye_WS, u_light_WS;
        uniform float u_fogDensity;
        uniform vec3 u_fogColor;
        uniform bool u_showCliffs, u_fogEnabled;

        out vec4 frag;
        void main() {
            vec3 N = normalize(v_wsNrm);
            vec3 L = normalize(u_light_WS - v_wsPos);
            vec3 V = normalize(u_eye_WS - v_wsPos);
            vec3 H = normalize(L + V);

            vec3 kd = vec3(0.65, 0.55, 0.40);
            if(u_showCliffs) {
                float slope = 1.0 - clamp(N.z, 0.0, 1.0);
                if(slope > 0.4) kd = mix(kd, vec3(0.2, 0.1, 0.05), smoothstep(0.4, 0.8, slope));
            }

            float diff = max(dot(N, L), 0.0);
            float spec = pow(max(dot(N, H), 0.0), 32.0);
            vec3 litColor = kd * diff + vec3(1.0) * spec * 0.25 + kd * 0.15;

            // Fog
            if(u_fogEnabled) {
                float d = 1.0 / gl_FragCoord.w;
                float visibility = exp(-u_fogDensity * d);
                frag = vec4(mix(u_fogColor, litColor, clamp(visibility, 0.0, 1.0)), 1.0);
            } else {
                frag = vec4(litColor, 1.0);
            }
        }`;

        function createShader(gl, type, src) {
            const s = gl.createShader(type); gl.shaderSource(s, src); gl.compileShader(s);
            if(!gl.getShaderParameter(s, gl.COMPILE_STATUS)) throw new Error(gl.getShaderInfoLog(s));
            return s;
        }
        const prog = gl.createProgram();
        gl.attachShader(prog, createShader(gl, gl.VERTEX_SHADER, VS));
        gl.attachShader(prog, createShader(gl, gl.FRAGMENT_SHADER, FS));
        gl.linkProgram(prog);

        const loc = {
            u_M: gl.getUniformLocation(prog, 'u_M'), u_V: gl.getUniformLocation(prog, 'u_V'), u_P: gl.getUniformLocation(prog, 'u_P'),
            u_eye_WS: gl.getUniformLocation(prog, 'u_eye_WS'), u_light_WS: gl.getUniformLocation(prog, 'u_light_WS'),
            u_fogDensity: gl.getUniformLocation(prog, 'u_fogDensity'), u_fogColor: gl.getUniformLocation(prog, 'u_fogColor'),
            u_showCliffs: gl.getUniformLocation(prog, 'u_showCliffs'), u_fogEnabled: gl.getUniformLocation(prog, 'u_fogEnabled')
        };

        let mesh = { vao: null, count: 0, posData: null };

        function applyWeather(pos, g, iters) {
            iters = Math.max(0, iters | 0);
            if (iters === 0) return;
            const N = g * g;
            const z = new Float32Array(N);
            const zNext = new Float32Array(N);
            for (let i = 0; i < N; i++) z[i] = pos[i * 3 + 2];
            for (let t = 0; t < iters; t++) {
                for (let j = 0; j < g; j++) {
                    for (let i = 0; i < g; i++) {
                        const id = j * g + i;
                        let sum = 0.0, cnt = 0;
                        if (j > 0) { sum += z[(j - 1) * g + i]; cnt++; }
                        if (j < g - 1) { sum += z[(j + 1) * g + i]; cnt++; }
                        if (i > 0) { sum += z[j * g + (i - 1)]; cnt++; }
                        if (i < g - 1) { sum += z[j * g + (i + 1)]; cnt++; }
                        const m = (cnt > 0) ? (sum / cnt) : z[id];
                        zNext[id] = 0.5 * (z[id] + m);
                    }
                }
                z.set(zNext);
            }
            for (let i = 0; i < N; i++) pos[i * 3 + 2] = z[i];
        }

        function generateTerrain() {
            const g = settings.gridSize, f = settings.faults;
            const pos = new Float32Array(g * g * 3);
            const step = 2 / (g - 1);
            for(let j=0; j<g; j++) {
                for(let i=0; i<g; i++) {
                    const id = (j*g+i)*3;
                    pos[id] = -1 + i*step; pos[id+1] = -1 + j*step; pos[id+2] = 0;
                }
            }
            for(let i=0; i<f; i++) {
                const t = f <= 1 ? 0 : i/(f-1);
                const d = (0.55 * step) * Math.pow(1.0 - t, settings.complexity);
                const ang = Math.random()*Math.PI*2, nx = Math.cos(ang), ny = Math.sin(ang);
                const px = Math.random()*2-1, py = Math.random()*2-1;
                for(let v=0; v<pos.length; v+=3) {
                    if(((pos[v]-px)*nx + (pos[v+1]-py)*ny) > 0) pos[v+2] += d;
                    else pos[v+2] -= d;
                }
            }
            applyWeather(pos, g, settings.weatheringDegree);

            let minH=1e9, maxH=-1e9;
            for(let v=2; v<pos.length; v+=3) { minH=Math.min(minH, pos[v]); maxH=Math.max(maxH, pos[v]); }
            if(maxH > minH) {
                for(let v=2; v<pos.length; v+=3) pos[v] = ((pos[v]-minH)/(maxH-minH)-0.5)*2.0;
            }
            mesh.posData = pos;

            const nrm = new Float32Array(pos.length);
            for(let j=0; j<g; j++) {
                for(let i=0; i<g; i++) {
                    const id=(j*g+i)*3, iL=Math.max(i-1,0), iR=Math.min(i+1,g-1), jB=Math.max(j-1,0), jT=Math.min(j+1,g-1);
                    const dzdx = (pos[(j*g+iR)*3+2]-pos[(j*g+iL)*3+2])/(step*2);
                    const dzdy = (pos[(jT*g+i)*3+2]-pos[(jB*g+i)*3+2])/(step*2);
                    const n = norm3(V3(-dzdx, -dzdy, 1.0));
                    nrm[id]=n[0]; nrm[id+1]=n[1]; nrm[id+2]=n[2];
                }
            }
            const idx = new Uint32Array((g-1)*(g-1)*6);
            let k=0;
            for(let j=0; j<g-1; j++) {
                for(let i=0; i<g-1; i++) {
                    const a=j*g+i, b=a+1, c=a+g, d=c+1;
                    idx[k++]=a; idx[k++]=b; idx[k++]=c; idx[k++]=b; idx[k++]=d; idx[k++]=c;
                }
            }
            if(mesh.vao) gl.deleteVertexArray(mesh.vao);
            mesh.vao = gl.createVertexArray(); gl.bindVertexArray(mesh.vao);
            const setupBuf = (data, loc) => {
                const b = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, b);
                gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW);
                gl.enableVertexAttribArray(loc); gl.vertexAttribPointer(loc, 3, gl.FLOAT, false, 0, 0);
            };
            setupBuf(pos, 0); setupBuf(nrm, 1);
            const ibo = gl.createBuffer(); gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ibo);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, idx, gl.STATIC_DRAW);
            mesh.count = idx.length;
        }

        function sampleHeight(x, y) {
            if(!mesh.posData) return 0;
            const G = settings.gridSize;
            const iFloat = ((x + 1) * 0.5) * (G - 1);
            const jFloat = ((y + 1) * 0.5) * (G - 1);
            const i0 = Math.floor(iFloat), j0 = Math.floor(jFloat);
            const i1 = Math.min(G - 1, i0 + 1), j1 = Math.min(G - 1, j0 + 1);
            const tx = Math.max(0, Math.min(1, iFloat - i0)), ty = Math.max(0, Math.min(1, jFloat - j0));
            const idxZ = (i, j) => (j * G + i) * 3 + 2;
            const z00 = mesh.posData[idxZ(i0, j0)], z10 = mesh.posData[idxZ(i1, j0)];
            const z01 = mesh.posData[idxZ(i0, j1)], z11 = mesh.posData[idxZ(i1, j1)];
            return (z00 * (1 - tx) + z10 * tx) * (1 - ty) + (z01 * (1 - tx) + z11 * tx) * ty;
        }


        const upWorld = V3(0, 0, 1);
        let eye = V3(2, -2, 2); 
        let fwd = norm3(V3(-1, 1, -0.7)); 
        const keys = {};

        function resetCamera(mode) {
            if (mode === 'Flight') {
                eye = V3(2.5, -2.5, 2.0);
                fwd = norm3(V3(-1, 1, -0.7)); 
            } else if (mode === 'Drive') {
                eye[0] = 0; eye[1] = 0;
                eye[2] = sampleHeight(0, 0) + settings.hoverHeight;
                fwd = norm3(V3(1, 1, -0.2)); 
            }
        }

        window.addEventListener('keydown', e => {
            keys[e.key] = true;
            if(e.key.toLowerCase() === 'f') settings.fogOn = !settings.fogOn;
            if(e.key.toLowerCase() === 'g') settings.fogDensity *= 0.8;
            if(e.key.toLowerCase() === 'h') settings.fogDensity *= 1.25;
            if(e.key === 'Enter') settings.regenerate();
        });
        window.addEventListener('keyup', e => keys[e.key] = false);

        function updateCamera(dt) {
            const speedMove = (settings.viewMode === 'Drive' ? 0.6 : 3.5);
            const speedRot = 1.3;
            const right = norm3(cross3(fwd, upWorld));
            let move = V3();
            if(keys['w'] || keys['W']) move = add3(move, fwd);
            if(keys['s'] || keys['S']) move = sub3(move, fwd);
            if(keys['a'] || keys['A']) move = sub3(move, right);
            if(keys['d'] || keys['D']) move = add3(move, right);
            if(len3(move) > 0) eye = add3(eye, mul3s(norm3(move), speedMove * dt));

            if(keys['ArrowLeft'])  fwd = rotateVecAroundAxis(fwd, upWorld, speedRot * dt);
            if(keys['ArrowRight']) fwd = rotateVecAroundAxis(fwd, upWorld, -speedRot * dt);
            if(keys['ArrowUp'])    fwd = rotateVecAroundAxis(fwd, right, speedRot * dt);
            if(keys['ArrowDown'])  fwd = rotateVecAroundAxis(fwd, right, -speedRot * dt);
            fwd = norm3(fwd);

            if(settings.viewMode === 'Drive') {
                eye[0] = Math.max(-0.99, Math.min(0.99, eye[0]));
                eye[1] = Math.max(-0.99, Math.min(0.99, eye[1]));
                const groundZ = sampleHeight(eye[0], eye[1]);
                const targetZ = groundZ + settings.hoverHeight;
                if (targetZ > eye[2]) eye[2] = targetZ; 
                else eye[2] += (targetZ - eye[2]) * Math.min(1.0, 10.0 * dt);
            }
        }

        const gui = new GUI({ title: 'Integrated Terrain Pro' });
        
        gui.add(settings, 'viewMode', ['Flight', 'Drive']).name('Control Mode')
           .onChange(v => {
               document.getElementById('mode-status').innerText = `Current Mode: ${v}`;
               resetCamera(v);
           });

        gui.add(settings, 'gridSize').name('Grid Size').step(1);
        gui.add(settings, 'faults').name('Faults').step(1);
        gui.add(settings, 'complexity', 0.5, 4).name('Complexity');
        gui.add(settings, 'weatheringDegree').name('Weathering (Smooth)').step(1);
        gui.add(settings, 'regenerate').name('Regenerate [Enter]');

        gui.add(settings, 'fogOn').name('Fog Enabled [F]').listen();
        gui.add(settings, 'fogDensity', 0, 1).name('Fog Density [G/H]').listen();
        gui.addColor(settings, 'fogColor').name('Fog Color');
        gui.add(settings, 'showCliffs').name('Show Cliffs');

        gui.add(settings, 'materialName').name('Material Map');

        let matP = new Float32Array(16);
        function resize() {
            canvas.width = window.innerWidth; canvas.height = window.innerHeight;
            gl.viewport(0, 0, canvas.width, canvas.height);
            const aspect = canvas.width / canvas.height;
            const f = 1/Math.tan((60*Math.PI/180)/2), near = 0.01, far = 100.0;
            matP.set([f/aspect,0,0,0, 0,f,0,0, 0,0,(far+near)/(near-far),-1, 0,0,(2*far*near)/(near-far),0]);
        }
        window.addEventListener('resize', resize); resize();

        function lookAt(ex, ey, ez, tx, ty, tz, ux, uy, uz) {
            let z=norm3(V3(ex-tx, ey-ty, ez-tz)), x=norm3(cross3(V3(ux,uy,uz), z)), y=cross3(z, x);
            const m=new Float32Array(16);
            m[0]=x[0]; m[4]=x[1]; m[8]=x[2]; m[1]=y[0]; m[5]=y[1]; m[9]=y[2]; m[2]=z[0]; m[6]=z[1]; m[10]=z[2];
            m[12]=-(x[0]*ex+x[1]*ey+x[2]*ez); m[13]=-(y[0]*ex+y[1]*ey+y[2]*ez); m[14]=-(z[0]*ex+z[1]*ey+z[2]*ez); m[15]=1;
            return m;
        }

        let lastT = performance.now();
        function frame(t) {
            const dt = Math.min(0.033, (t - lastT)/1000); lastT = t;
            updateCamera(dt);

            gl.clearColor(settings.fogColor[0], settings.fogColor[1], settings.fogColor[2], 1);
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
            gl.enable(gl.DEPTH_TEST);

            const matV = lookAt(eye[0], eye[1], eye[2], eye[0]+fwd[0], eye[1]+fwd[1], eye[2]+fwd[2], 0,0,1);
            const matM = new Float32Array([1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1]);

            gl.useProgram(prog);
            gl.uniformMatrix4fv(loc.u_M, false, matM);
            gl.uniformMatrix4fv(loc.u_V, false, matV);
            gl.uniformMatrix4fv(loc.u_P, false, matP);
            gl.uniform3f(loc.u_eye_WS, eye[0], eye[1], eye[2]);
            gl.uniform3f(loc.u_light_WS, 2, 2, 4);
            gl.uniform1f(loc.u_fogDensity, settings.fogOn ? settings.fogDensity : 0.0);
            gl.uniform3fv(loc.u_fogColor, settings.fogColor);
            gl.uniform1i(loc.u_showCliffs, settings.showCliffs);
            gl.uniform1i(loc.u_fogEnabled, settings.fogOn);

            if(mesh.vao) {
                gl.bindVertexArray(mesh.vao);
                gl.drawElements(gl.TRIANGLES, mesh.count, gl.UNSIGNED_INT, 0);
            }
            requestAnimationFrame(frame);
        }

        generateTerrain();
        resetCamera('Flight');
        requestAnimationFrame(frame);
    </script>
</body>
</html>
